---
title: "Appendix"
author: "Caleb Skinner"
format: pdf
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  comment = "#", fig.height = 3, 
  cache = FALSE,  collapse = TRUE,
  error = TRUE, echo = FALSE,
  message = FALSE)
```

```{r libraries, include = FALSE}
library("arrow")
library("here")
library("scales")
library("flextable")
library("tidyverse"); theme_set(theme_minimal())
library("tidymodels")
library("yardstick")
library("patchwork")
library("corrr")
library("janitor")
library("performance")
library("modelsummary")
```

```{r, include = FALSE}
set_flextable_defaults(
  font.size = 10, theme_fun = theme_apa,
  padding = 6,
  background.color = "#EFEFEF")
```

```{r data, include = FALSE}
cov <- read_parquet(here("covariates.parquet"))
gs <- read_parquet(here("grandslams2.parquet"))
```

The appendix includes additional figures and tables. For more context, please refer to the main text. The appendix is divided by the chapter to which it applies.

# Methodology

As we adjusted the point margin for the server, we assume that serve impact is additive. That is, we assume the overall impact from serving does not change as the point margin changes. In figure @fig-serve-impact-pm, we display the server's win probability at each point margin in our data set. The dashed line is the overall win rate for the server. To reduce noise, we only include point margins where at least 1100 points have been played. The figure shows that the serve impact does decrease slightly as the point margin increases for both men and women. However, the difference is not large enough to meaningfully impact our measurement of momentum. Thus, we continue with the assumption that serve impact is additive. Moreover, it is likely that this figure is impacted by sampling bias. Fewer points are played with large point margins, and these matches tend to have lower serve win rates.

```{r}
#| label: fig-serve-impact-pm
#| fig-cap: "Serve Impact by Point Margin"

gs %>%
  mutate(
    point_margin = abs(p1_points_won - p2_points_won),
    s_win = if_else(server == point_victor, 1, 0),
    sex = factor(sex, levels = c("1", "0"))) %>%
  group_by(match_id) %>%
  group_by(point_margin, sex) %>%
  summarise(
    s_win = mean(s_win),
    points = n()) %>%
  filter(points > 1100) %>%
  ggplot(aes(x = point_margin, s_win)) +
  geom_point(aes(color = sex), size = .8) +
  geom_smooth(aes(color = sex), se = FALSE) +
  scale_color_manual(name = 'Sex',
                     labels = c('1' = "Male", '0' = "Female"),
                     values = c('1' = 'cadetblue3', '0' = 'indianred2')) +
  geom_segment(aes(x = 0, y = .641, xend = 33, yend = .641), linetype = "dashed", color = "cadetblue3") +
  geom_segment(aes(x = 0, y = .570, xend = 25, yend = .570), linetype = "dashed", color = "indianred2") +
  labs(x = "Point Margin", y = "Server Win Rate")
```

Our second assumption regarding serve impact is that the server win percentage is constant over the course of a match. In @fig-serve-impact-match, we visualize the server's win percentage at each point in a match. To reduce noise, we only include points with at least 500 observations. We find that the server win rate does not meaninfully change over the course of a match.

```{r}
#| label: fig-serve-impact-match
#| fig-cap: "Serve Impact over Time"

gs %>%
  mutate(
    s_win = if_else(server == point_victor, 1, 0),
    # pt_group = (point_no - 1)%/%3,
    sex = factor(sex, levels = c("1", "0"))) %>%
  group_by(point_no, sex) %>%
  summarise(
    s_win = mean(s_win),
    points = n()) %>%
  filter(points > 500) %>%
  ggplot(aes(x = point_no, s_win)) +
  geom_point(aes(color = sex), size = .8) +
  geom_smooth(aes(color = sex), se = FALSE) +
  scale_color_manual(name = 'Sex',
                     labels = c('1' = "Male", '0' = "Female"),
                     values = c('1' = 'cadetblue3', '0' = 'indianred2')) +
  labs(x = "Point Number", y = "Server Win Rate")
```

@tbl-interpret supplements the figures in Describing Momentum. It contains the means and intervals of backward momentum in various conditions.

```{r}
#| label: tbl-interpret
#| tbl-cap: "Momentum Estimates for Example Sequences"
table_interpret <- gs %>%
  select(match_id, point_victor, gradient_backward, gradient_forward, point_no) %>%
  mutate(
    match_id = str_c(match_id, "_flip"),
    point_victor = if_else(point_victor == 1, 2, 1),
    gradient_backward = -gradient_backward,
    gradient_forward = -gradient_forward) %>%
  bind_rows(gs %>% select(point_victor, match_id, gradient_backward, gradient_forward, point_no)) %>%
  group_by(match_id) %>%
  mutate(
    point_victor = if_else(point_victor == 2, 0, point_victor),
    p1_points_won = cumsum(point_victor),
    fifteen_in_a_row = if_else((p1_points_won - lag(p1_points_won, 15) == 15), gradient_backward, NA),
    sixteen_out_of_twenty = if_else((p1_points_won - lag(p1_points_won, 20) == 16), gradient_backward, NA),
    twelve_out_of_fifteen = if_else((p1_points_won - lag(p1_points_won, 15) == 12), gradient_backward, NA),
    ten_in_a_row = if_else((p1_points_won - lag(p1_points_won, 10) == 10), gradient_backward, NA),
    eight_out_of_ten = if_else((p1_points_won - lag(p1_points_won, 10) == 8), gradient_backward, NA),
    four_out_of_five = if_else((p1_points_won - lag(p1_points_won, 5) == 4), gradient_backward, NA),
    five_in_a_row = if_else((p1_points_won - lag(p1_points_won, 5) == 5), gradient_backward, NA),
    three_in_a_row = if_else((p1_points_won - lag(p1_points_won, 3) == 3), gradient_backward, NA)) %>%
  ungroup() %>%
  select(contains("row"), contains("out_of")) %>%
  filter(!is.na(fifteen_in_a_row) | !is.na(ten_in_a_row) | !is.na(five_in_a_row) | !is.na(three_in_a_row) | !is.na(sixteen_out_of_twenty) | !is.na(eight_out_of_ten) | !is.na(twelve_out_of_fifteen) | !is.na(four_out_of_five))

int_levels <- c("fifteen_in_a_row", "ten_in_a_row", "five_in_a_row", "three_in_a_row", "sixteen_out_of_twenty", "twelve_out_of_fifteen", "eight_out_of_ten", "four_out_of_five")

table_interpret %>%
  pivot_longer(everything(), names_to = "group") %>%
  filter(!is.na(value)) %>%
  mutate(Sequence = factor(group, levels = int_levels)) %>%
  group_by(Sequence) %>%
  summarize(
    `2.5%` = quantile(value, .025, na.rm = TRUE),
    Mean = mean(value, na.rm = TRUE),
    `97.5%` = quantile(value, .975, na.rm = TRUE),
    `Sample Size` = n()) %>%
  mutate(across(where(is.numeric), ~round(.x, digits = 3)),
         Sequence = str_replace_all(Sequence, "_", " "),
         Sequence = str_to_title(Sequence)) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  width(j = 1, width = 1.6) %>%
  width(j = 5, width = 1)
```

# Results

## Does Momentum Exist?

```{r}
app_prep_table <- function(fit, name){
  fit %>%
    tidy() %>%
    clean_names() %>%
    select(-statistic) %>%
    filter(!str_detect(term, "tournament")) %>%
    mutate(
      across(where(is.numeric), ~round(.x, digits = 4)),
      symbol = case_when(
        p_value < .001 ~ "***",
        p_value < .01 ~ "**",
        p_value < .05 ~ "*",
        .default = ""),
      estimate = str_c(as.character(format(estimate, scientific = FALSE)), symbol),
      std_error = str_c("(", format(std_error, scientific = FALSE), ")")) %>%
    slice(1:3) %>%
    mutate(term = c("Intercept", "backward_momentum", "bet_odds")) %>%
    pivot_longer(cols = c(estimate, std_error), names_to = "metric", values_to = name) %>%
    select(-p_value, -symbol, -metric)
}

app_prep_log_table <- function(men_fit, women_fit, combined_fit){
  em_men <- men_fit %>%
    app_prep_table("men") %>%
    select(men)
  
  em_women <- women_fit %>%
    app_prep_table("women") %>%
    select(women)
  
  combined_fit %>%
    app_prep_table("combined") %>%
    bind_cols(em_men) %>%
    bind_cols(em_women) %>%
    mutate(
      term = str_replace_all(term, "_", " "),
      term = str_to_title(term),
      term = recode(term,
                     "Bet Odds" = "Pre-Match Win Probability")) %>%
    rename_with(str_to_title)
}

lr_mod <- logistic_reg() %>% 
  set_engine("glm")

exist_momentum_men <- lr_mod %>%
  fit(point_victor ~ tournament:sex:server + lag1_gradient_backward:sex + lag1_gradient_backward + bet_odds*sex, data = cov)

cov2 <- cov %>% mutate(sex = factor(sex, levels = c("women", "men")))

exist_momentum_women <- lr_mod %>%
  fit(point_victor ~ tournament:sex:server + lag1_gradient_backward:sex + lag1_gradient_backward + bet_odds*sex, data = cov2)

exist_momentum_combined <- lr_mod %>%
  fit(point_victor ~ tournament:sex:server + lag1_gradient_backward + bet_odds, data = cov)

# linearity assumption for logistic regression
cov %>%
  mutate(
    victor_res = exist_momentum_combined$fit$coefficients[2]*lag1_gradient_backward + exist_momentum_combined$fit$residuals) %>%
  sample_n(1000) %>%
  ggplot(aes(x = lag1_gradient_backward, y = victor_res)) +
  geom_point() +
  geom_smooth(color = "cadetblue3", method = "lm", linetype = "dashed", se = F) +
  geom_smooth(color = "indianred3", se = F)

# autocorrelation
lmtest::dwtest(point_victor ~ lag1_gradient_backward, data = cov %>% mutate(point_victor = as.numeric(point_victor)), alternative = "two.sided")

lmtest::dwtest(point_victor ~ tournament:sex:server + lag1_gradient_backward + bet_odds, data = cov %>% mutate(point_victor = as.numeric(point_victor)), alternative = "two.sided")

tibble("Formula" = c("Backward Momentum", "Backward Momentum and Controls"),
       "Durbin Watson Statistic" = c(1.9408, 1.9992),
       "P Value" = c("~0", ".998")) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  width(j = 1, width = 2.5) %>%
  width(j = c(2), width = 1.5) %>%
  colformat_double(j = 2, digits = 4)
```

@tbl-full-log-odds displays the log odds for all variables in the model evaluating the relationship between backward momentum and point victor. The dependent variable is player 1's odds of winning the next point.

```{r, ft.keepnext = FALSE}
#| label: tbl-full-log-odds
#| tbl-cap: "Momentum Exist - All Variables"

exist_momentum_men %>%
  tidy() %>%
  clean_names() %>%
  select(-statistic) %>%
  mutate(
    across(where(is.numeric), ~round(.x, digits = 4)),
    symbol = case_when(
      p_value < .001 ~ "***",
      p_value < .01 ~ "**",
      p_value < .05 ~ "*",
      .default = ""),
    estimate = str_c(as.character(format(estimate, scientific = FALSE)), symbol),
    term = str_remove(term, "sex"),
    term = str_replace(term, "server0", "returner"),
    term = str_replace(term, "open", "_open"),
    term = str_remove(term, "tournament"),
    term = str_remove(term, "p1_"),
    term = str_remove_all(term, "1"),
    term = str_replace_all(term, "_", " "),
    term = str_replace_all(term, ":", " & "),
    term = str_replace_all(term, "lag gradient backward", "backward momentum"),
    term = str_replace_all(term, "bet odds", "Pre-Match Win Probability"),
    term = str_to_title(term),
    term = str_replace(term, "Us", "US"),
    term = str_replace(term, "Aus", "Australian")) %>%
  slice(-18, -22) %>%
  select(-p_value, -symbol) %>%
  rename("Standard Error" = "std_error") %>%
  rename_with(str_to_title) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  width(j = 1, width = 2) %>%
  width(j = 3, width = 1.2)
```

```{r}
#| label: fig-victor-win-percentage
#| fig-cap: "Victor Win Percentage"
gs %>% group_by(match_id) %>% summarise(
  points_won_by_winner = sum(match_victor == point_victor)/n()) %>%
  ggplot() +
  geom_density(aes(x = points_won_by_winner), color = "indianred3") +
  # geom_segment(aes(x = .541, xend = .541, y = 0, yend = 11), linetype = "dashed", color = "indianred3") +
  labs(y = "", title = "Victor Point Win Percentage", x = "") +
  scale_y_continuous(breaks = NULL) +
  scale_x_continuous(labels = scales::percent)
```

In @fig-betting-odds-server-momentum, we display backward momentum's effect on the point victor with varying betting odds and servers. In this situation, we describe high betting odds as a 99% implied win probability, even betting odds as a 50% implied win probability, and low betting odds as a 1% implied win probability. For all curves, the estimates are for women playing at Wimbledon.

```{r}
#| label: fig-betting-odds-server-momentum
#| fig-cap: "Backward Momentum on Win Probability with various betting odds and servers"

e_co <- exist_momentum_men %>%
  tidy() %>%
  clean_names() %>%
  select(-statistic, -std_error, -p_value)

# womens varying betting odds, assume Wimbledon
predicted_women_vary_bet_odds <- tibble(
  backward_gradient = seq(-1, 1, by = .01),
  odds_wswh = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 99*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[21]),
  pred_wswh = odds_wswh/(1+odds_wswh),
  odds_wswe = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 50*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[21]),
  pred_wswe = odds_wswe/(1+odds_wswe),
  odds_wswl = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 1*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[21]),
  pred_wswl = odds_wswl/(1+odds_wswl),

  odds_wrwh = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 99*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[14]),
  pred_wrwh = odds_wrwh/(1+odds_wrwh),
  odds_wrwe = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 50*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[14]),
  pred_wrwe = odds_wrwe/(1+odds_wrwe),
  odds_wrwl = exp(e_co$estimate[1] + e_co$estimate[4] + backward_gradient*(e_co$estimate[2] + e_co$estimate[5]) + 1*(e_co$estimate[3] + e_co$estimate[6]) + e_co$estimate[14]),
  pred_wrwl = odds_wrwl/(1+odds_wrwl))

predicted_women_vary_bet_odds %>%
  pivot_longer(cols = c(pred_wswh, pred_wswe, pred_wswl, pred_wrwh, pred_wrwe, pred_wrwl), names_to = "type", values_to = "probability") %>%
  select(backward_gradient, type, probability) %>%
  mutate(
    `Bet Odds` = case_when(
      str_detect(type, "wh") ~ "High",
      str_detect(type, "wl") ~ "Low",
      str_detect(type, "we") ~ "Even",
      .default = NA),
    Server = case_when(
      str_detect(type, "ws") ~ "Server",
      str_detect(type, "wr") ~ "Returner",
      .default = NA),
    `Bet Odds` = factor(`Bet Odds`, levels = c("High", "Even", "Low"))
    ) %>%
  ggplot() +
  geom_line(aes(x = backward_gradient, y = probability, color = `Bet Odds`, linetype = Server)) +
  scale_color_manual(
    values = c(`Even` = "navyblue", `Low` = "indianred3", `High` = "forestgreen"),
    # breaks = c("Wimbledon", "US Open", "Australian Open", "French Open"),
    # labels = c("Wimbledon", "US Open", "Australian Men", "French Men", "Wimbledon Women", "US Women", "Australian Women", "French Women"),
    name = "Betting Odds") +
  scale_linetype_manual(
        values = c(Server = "solid", Returner = "dashed"),
        name = "") +
  labs(x = "Backward Momentum", y = "Point Win Probability", title = "Win Probability by Momentum") +
  scale_y_continuous(labels = scales::percent)
```

In @fig-approach-assumptions, we test the assumptions of the linear model regressing **backward_momentum** on **future_momentum**. For readability, we take a random sample of 1000 points from the model. This subset appears to meet all the model's assumptions. The first plot demonstrates that the residuals appear to be normally distributed. The second plot assesses the model's linearity conditions. The third plot evaluates the homogeneity of variance. None of the covariates have any meaningful correlation.

```{r, fig.height = 6}
#| label: fig-approach-assumptions
#| fig-cap: "Assumptions for Second Approach"

lm_spec <- linear_reg() %>%
  set_mode("regression") %>%
  set_engine("lm")

momentum_relationship <- lm_spec %>%
  fit(gradient_forward ~ server:sex:tournament + bet_odds + gradient_backward, data = cov %>% mutate(gradient_backward = gradient_backward*2))

cov_men <- cov %>% filter(sex == "men")

momentum_relationship_men <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + gradient_backward, data = cov_men %>% mutate(gradient_backward = gradient_backward*2))

cov_women <- cov %>% filter(sex == "women")

momentum_relationship_women <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + gradient_backward, data = cov_women %>% mutate(gradient_backward = gradient_backward*2))

# residuals
set.seed(1)
momentum_residuals <- tibble(residual = momentum_relationship$fit$residuals,
                        fitted = momentum_relationship$fit$fitted.values) %>%
  sample_n(1000) %>%
  arrange(residual) %>%
  mutate(
    rank = row_number(),
    ordered_values = (residual - mean(residual))/sd(residual),
    sqrt_ordered_values = sqrt(abs(ordered_values)),
    theoretical_quantiles = qnorm(rank/(n() + 1), 0, 1))

# qq plot
qq_mom <- momentum_residuals %>% ggplot() +
  geom_point(aes(theoretical_quantiles, ordered_values), color = "cadetblue4") +
  geom_abline(intercept = 0, slope = 1, color = "indianred3") +
  labs(title = "Q-Q Plot", x = "Theoretical Quantiles", y = "Ordered Values")

# linearity
linear_mom <- momentum_residuals %>% ggplot(aes(fitted, residual)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Linearity", x = "Fitted Values", y = "Residuals")

# homogeneity of variance
homogeneity_mom <- momentum_residuals %>% ggplot(aes(fitted, sqrt_ordered_values)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Homogeneity of Variance", x = "Fitted Values", y = "Variation")

qq_mom/linear_mom/homogeneity_mom
```

@tbl-second-full-results displays the full results for the second approach. The dependent variable is **future_momentum**.

```{r}
#| label: tbl-second-full-results
#| tbl-cap: "Momentum Relationship Model Full Results"

prep_linear_table_appendix <- function(model_fit, name){
  model_fit %>% 
    pluck("fit") %>%
    tidy() %>%
    clean_names() %>%
    select(-statistic) %>%
    na.omit() %>%
    mutate(
      across(where(is.numeric), ~round(.x, digits = 4)),
      symbol = case_when(
        p_value < .001 ~ "***",
        p_value < .01 ~ "**",
        p_value < .05 ~ "*",
        .default = ""),
      estimate = str_c(as.character(format(estimate, scientific = FALSE)), symbol),
      std_error = str_c("(", format(std_error, scientific = FALSE), ")")) %>%
    pivot_longer(cols = c(estimate, std_error), names_to = "metric", values_to = name) %>%
    select(-symbol, -p_value)
}

momentum_relationship %>%
  prep_linear_table_appendix("full") %>%
  full_join(momentum_relationship_men %>% prep_linear_table_appendix("men") %>% mutate(term = str_replace_all(term, "tourn", "sexmen:tourn")), by = join_by(term, metric)) %>%
  full_join(momentum_relationship_women %>% prep_linear_table_appendix("women") %>% mutate(term = str_replace_all(term, "tourn", "sexwomen:tourn")), by = join_by(term, metric)) %>%
      mutate(
        term = recode(term,
                      "bet_odds" = "Pre-Match Win Probability",
                      "gradient_backward" = "Backward Momentum"),
        term = str_replace_all(term, "_", " "),
        term = str_replace_all(term, ":", " & "),
        term = str_remove(term, "\\("),
        term = str_remove(term, "\\)"),
        term = str_replace_all(term, "server1", "server"),
        term = str_replace_all(term, "server0", "returner"),
        term = str_remove(term, "sex"),
        term = str_remove(term, "tournament"),
        term = str_replace_all(term, "open", " open"),
        term = str_to_title(term),
        term = str_replace(term, "Us", "US"),
        term = str_replace(term, "Aus", "Australian")) %>%
  select(-metric) %>%
  rename_with(str_to_title)
  flextable() %>%
  align(align = "center", part = "all") %>%
  merge_v(j = ~Term) %>%
  width(j = 1, width = 2)
```

## What Factors Impact Momentum?

In @fig-point-assumptions, we test the assumptions for the point-level linear regression. For readability, we take a random sample of 1000 points from the model. The first three plots appear to meet all the model's assumptions. The first plot demonstrates that the residuals appear to be normally distributed. The second plot addresses the model's linearity conditions. The third plot evaluates the homogeneity of variance. @tbl-point-multicollinearity and @fig-point-correlation-matrix demonstrates the correlation of the covariates. **Server**, **sex**, **long_point**, **break_converted**, **break_saved**, and **bet_odds** are removed from the correlation matrix for readability. They have no large associations with any of the other covariates. The largest correlation is about .44 and between **point_victor** and **winner** and **unf_err**. The results from the assumptions tests are almost identical to the reduced model.

```{r, fig.height = 6}
#| label: fig-point-assumptions
#| fig-cap: "Assumptions for Point Level"

cov_model <- lm_spec %>%
  fit(gradient_forward ~ server:sex:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov)

cov_model_men <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov_men)

cov_model_women <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov_women)

cov_close <- cov %>% filter(between(bet_odds, 40, 60))

cov_model_close <- lm_spec %>%
  fit(gradient_forward ~ server:sex:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov_close)

cov_close_men <- cov_men %>% filter(between(bet_odds, 40, 60))

cov_model_close_men <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov_close_men)

cov_close_women <- cov_women %>% filter(between(bet_odds, 40, 60))

cov_model_close_women <- lm_spec %>%
  fit(gradient_forward ~ server:tournament + bet_odds + point_victor + 
        point_victor:long_point + break_converted + break_saved +
        p1_winner + p2_winner + p1_ace + p2_ace + p1_double_fault + p2_double_fault +
        p1_unf_err + p2_unf_err, data = cov_close_women)

# residuals
set.seed(1)
point_residuals <- tibble(residual = cov_model$fit$residuals,
                        fitted = cov_model$fit$fitted.values) %>%
  sample_n(1000) %>%
  arrange(residual) %>%
  mutate(
    rank = row_number(),
    ordered_values = (residual - mean(residual))/sd(residual),
    sqrt_ordered_values = sqrt(abs(ordered_values)),
    theoretical_quantiles = qnorm(rank/(n() + 1), 0, 1))

# qq plot
qq_point <- point_residuals %>% ggplot() +
  geom_point(aes(theoretical_quantiles, ordered_values), color = "cadetblue4") +
  geom_abline(intercept = 0, slope = 1, color = "indianred3") +
  labs(title = "Q-Q Plot", x = "Theoretical Quantiles", y = "Ordered Values")

# linearity
linear_point <- point_residuals %>% ggplot(aes(fitted, residual)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Linearity", x = "Fitted Values", y = "Residuals")

# homogeneity of variance
homogeneity_point <- point_residuals %>% ggplot(aes(fitted, sqrt_ordered_values)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Homogeneity of Variance", x = "Fitted Values", y = "Variation")

qq_point/linear_point/homogeneity_point
```

```{r}
#| label: tbl-point-multicollinearity
#| tbl-cap: "Point Level Covariates Multicollinearity"

cov_model %>% check_collinearity() %>%
  as_tibble() %>%
  arrange(desc(VIF)) %>%
  select(Term, VIF) %>%
  mutate(across(where(is.numeric), ~round(.x, digits = 4))) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  width(j = 1, width = 2)
```

```{r}
#| label: fig-point-correlation-matrix
#| fig-cap: "Point Level Covariates Correlation Matrix"
cov_cor <- cov %>%
  select(point_victor, p1_winner, p2_winner, p1_ace, p2_ace, p1_double_fault, p2_double_fault, p1_unf_err, p2_unf_err) %>%
  mutate(
    across(point_victor:p2_unf_err, ~as.double(.x))) %>%
  correlate()

cov_cor %>% rplot(.order = "alphabet") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

In @tbl-point-full-results, we display the full results for the point-level linear model. The dependent variable is **future_momentum**.

```{r}
#| label: tbl-point-full-results
#| tbl-cap: "Point Level Model Full Results"

prep_linear_tables_appendix <- function(comb_full, comb_reduced, men_full, men_reduced, women_full, women_reduced){
  c1 <- prep_linear_table_appendix(comb_reduced, "Combined Reduced")
  c2 <- prep_linear_table_appendix(comb_full, "Combined Full") %>%
    left_join(c1, by = join_by(term, metric))
  m1 <- prep_linear_table_appendix(men_reduced, "Men Reduced") %>% mutate(term = str_replace_all(term, "tourn", "sexmen:tourn"))
  m2 <- prep_linear_table_appendix(men_full, "Men Full") %>% mutate(term = str_replace_all(term, "tourn", "sexmen:tourn")) %>%
    left_join(m1, by = join_by(term, metric))
  w1 <- prep_linear_table_appendix(women_reduced, "Women Reduced") %>% mutate(term = str_replace_all(term, "tourn", "sexwomen:tourn"))
  w2 <- prep_linear_table_appendix(women_full, "Women Full") %>% mutate(term = str_replace_all(term, "tourn", "sexwomen:tourn")) %>%
    left_join(w1, by = join_by(term, metric))

  full_join(c2, m2, by = join_by(term, metric)) %>%
    left_join(w2, by = join_by(term, metric)) %>%
    mutate(
      term = str_replace_all(term, "unf_err1", "unforced_error"),
      term = str_replace_all(term, "double_fault1", "double_fault"),
      term = str_replace_all(term, "_", " "),
      term = str_replace_all(term, ":", " & "),
      term = str_replace_all(term, "server1", "server"),
      term = str_replace_all(term, "server0", "returner"),
      term = str_remove(term, "sex"),
      term = str_remove(term, "tournament"),
      term = str_replace_all(term, "open", " open"),
      term = str_replace_all(term, "victor1", "victor"),
      term = str_replace_all(term, "victor0", "loser"),
      term = str_replace_all(term, "ace1", "ace"),
      term = str_replace_all(term, "winner1", "winner"),
      term = str_replace_all(term, "point1", "point"),
      term = str_replace_all(term, "ends1", "ends"),
      term = str_replace_all(term, "interruption1", "interruption"),
      term = str_to_title(term),
      term = str_replace(term, "Us", "US"),
      term = str_replace(term, "Aus", "Australian"),
      term = recode(term,
                    "Bet Odds" = "Pre-Match Win Probability",
                    "Break Saved1" = "P1 Break Saved",
                    "Break Saved2" = "P2 Break Saved",
                    "Break Converted1" = "P1 Break Converted",
                    "Break Converted2" = "P2 Break Converted",
                    "Set Victor" = "P1 Set Victor",
                    "Set Victor2" = "P2 Set Victor",
                    "Tiebreak Victor" = "P1 Tiebreak Victor",
                    "Tiebreak Victor2" = "P2 Tiebreak Victor",
                    )) %>%
    select(-metric) %>%
    rename_with(str_to_title)
}

prep_linear_tables_appendix(cov_model, cov_model_close, cov_model_men, cov_model_close_men, cov_model_women, cov_model_close_women) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  merge_v(j = ~Term) %>%
  add_header_row(
    values = c("", "Combined", "Men", "Women"),
    colwidths = c(1, 2, 2, 2), top = TRUE) %>%
  set_header_labels(values = c("Term", "Full", "Reduced", "Full", "Reduced", "Full", "Reduced")) %>%
  width(j = 1, width = 2)
```

In @fig-game-assumptions, we test the assumptions for the game-level linear regression. For readability, we take a random sample of 1000 points from the model. This subset appears to meet all the model's assumptions. The first plot demonstrates that the residuals appear to be normally distributed. The second plot addresses the model's linearity conditions. The third plot evaluates the homogeneity of variance. @tbl-game-multicollinearity and @fig-game-correlation-matrix displays the correlation of the covariates. **Sex** and **bet_odds** are removed from the correlation matrix for readability. They have no large associations with any of the other covariates. The largest correlation is .805 between **interruption** and **change_ends**. There is also a large correlation between **server** and **game_victor** (.496). The results from the assumptions tests are almost identical to the reduced model.

```{r, fig.height = 6}
#| label: fig-game-assumptions
#| fig-cap: "Assumptions for Game Level"

game_cov <- cov %>%
  group_by(match_id) %>%
  mutate(
    interruption = factor(lead(interruption)),
    change_ends = factor(lead(change_ends))) %>%
  filter(last_pt_game == 1) %>%
  mutate(
    set_victor = case_when(
      last_pt_set == "1" & game_victor == "1" ~ 1,
      last_pt_set == "1" & game_victor == "2" ~ 2,
      .default = 0) %>% factor(),
    lead1_gradient_forward = lead(gradient_forward),
    game_victor = factor(if_else(game_victor == 2, 0, 1)),
    tiebreak_victor = tiebreak_victory) %>%
  select(-tiebreak_victory) %>%
  ungroup()

game_cov_model <- lm_spec %>%
  fit(gradient_forward ~ server:sex:tournament + game_victor:server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov)

# residuals
set.seed(1)
game_residuals <- tibble(residual = game_cov_model$fit$residuals,
                        fitted = game_cov_model$fit$fitted.values) %>%
  sample_n(1000) %>%
  arrange(residual) %>%
  mutate(
    rank = row_number(),
    ordered_values = (residual - mean(residual))/sd(residual),
    sqrt_ordered_values = sqrt(abs(ordered_values)),
    theoretical_quantiles = qnorm(rank/(n() + 1), 0, 1))

# qq plot
qq_game <- game_residuals %>% ggplot() +
  geom_point(aes(theoretical_quantiles, ordered_values), color = "cadetblue4") +
  geom_abline(intercept = 0, slope = 1, color = "indianred3") +
  labs(title = "Q-Q Plot", x = "Theoretical Quantiles", y = "Ordered Values")

# linearity
linear_game <- game_residuals %>% ggplot(aes(fitted, residual)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Linearity", x = "Fitted Values", y = "Residuals")

# homogeneity of variance
homogeneity_game <- game_residuals %>% ggplot(aes(fitted, sqrt_ordered_values)) +
  geom_point(color = "cadetblue3") +
  geom_smooth(color = "forestgreen", se = FALSE) +
  labs(title = "Homogeneity of Variance", x = "Fitted Values", y = "Variation")

qq_game/linear_game/homogeneity_game
```

```{r}
#| label: tbl-game-multicollinearity
#| tbl-cap: "Game Level Covariates Multicollinearity"
game_cov_model %>% check_collinearity() %>%
  as_tibble() %>%
  arrange(desc(VIF)) %>%
  select(Term, VIF) %>%
  mutate(across(where(is.numeric), ~round(.x, digits = 4))) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  width(j = 1, width = 2)
```

```{r}
#| label: fig-game-correlation-matrix
#| fig-cap: "Game Level Covariates Correlation Matrix"
game_cov_cor <- game_cov %>%
  select(server, game_victor, interruption, change_ends, tiebreak_victor, set_victor) %>%
  mutate(
    across(server:set_victor, ~as.double(.x))) %>%
  correlate()

game_cov_cor %>% rplot(.order = "alphabet") +
  theme(axis.text.x = element_text(angle = 22.5, hjust = 1))
```

In @tbl-game-full-results, we show the full results for the six game level models.

```{r}
#| label: tbl-game-full-results
#| tbl-cap: "Game Level Model Full Results"

game_cov_men <- game_cov %>% filter(sex == "men")

game_cov_model_men <- lm_spec %>%
  fit(gradient_forward ~ game_victor:server + server:tournament + server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov_men)

game_cov_women <- game_cov %>% filter(sex == "women")

game_cov_model_women <- lm_spec %>%
  fit(gradient_forward ~ game_victor:server + server:tournament + server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov_women)

game_cov_close <- game_cov %>%
  filter(between(bet_odds, 40, 60))

game_cov_model_close <- lm_spec %>%
  fit(gradient_forward ~ game_victor:server + server:sex:tournament + server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov_close)

game_cov_close_men <- game_cov_close %>% filter(sex == "men")

game_cov_model_close_men <- lm_spec %>%
  fit(gradient_forward ~ game_victor:server + server:tournament + server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov_close_men)

game_cov_close_women <- game_cov_close %>% filter(sex == "women")

game_cov_model_close_women <- lm_spec %>%
  fit(gradient_forward ~ game_victor:server + server:tournament + server + game_victor + bet_odds + interruption:game_victor + change_ends:game_victor + 
        tiebreak_victor + set_victor, data = game_cov_close_women)


prep_linear_tables_appendix(game_cov_model, game_cov_model_close, game_cov_model_men, game_cov_model_close_men, game_cov_model_women, game_cov_model_close_women) %>%
  flextable() %>%
  align(align = "center", part = "all") %>%
  merge_v(j = ~Term) %>%
  add_header_row(
    values = c("", "Combined", "Men", "Women"),
    colwidths = c(1, 2, 2, 2), top = TRUE) %>%
  set_header_labels(values = c("Term", "Full", "Reduced", "Full", "Reduced", "Full", "Reduced")) %>%
  width(j = 1, width = 2)
```

